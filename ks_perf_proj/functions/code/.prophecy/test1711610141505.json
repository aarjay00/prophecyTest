{"initCode":"","code":" udf((argTargetTable: String, argSleepMins: String, argAbortOnTimeoutMins: String) => {\n  var sleepFORABit: Any = null\nvar retCode: Any = null\nvar invocationIDComponentList: Any = null\nvar jobInvocation: Any = null\nvar Ans: Any = null\nvar noOfInvocationIDComponents: Any = null\nvar loopCounter: Any = null\nvar StatusToCheckFOR: Any = null\nvar noOfInvocations: Any = null\nvar abortOnTimeout: Any = null\nvar invList: Any = null\nvar jobInvStatus: Any = null\nvar invocationTableName: Any = null\nvar jobInvocationID: Any = null\nvar jobHandle: Any = null\nvar maxLoops: Any = null\nAns = -1.0\ndsloginfo(ds_string_concat(ds_string_concat(ds_string_concat(ds_string_concat(ds_string_concat(ds_string_concat(\"PIBThrottleInvocation(\", argTargetTable), \",\"), argSleepMins), \",\"), argAbortOnTimeoutMins), \") CALLed\"), DSJ.ME)\nStatusToCheckFOR = DSJS.RUNNING\nabortOnTimeout = false\nsleepFORABit = false\nmaxLoops = argAbortOnTimeoutMins / argSleepMins\nprint\nmaxLoops\nloopCounter = 1.0\n\nwhile(ds_not((abortOnTimeout || ds_not(sleepFORABit)) && (loopCounter != 1.0))) {\nsleepFORABit = false\njobHandle = dsattachjob(\"pjDominoProcessMIActionElement_DropRN\", DSJ.ERRFATAL)\ninvList = dsgetjobinfo(jobHandle, DSJ.JOBINVOCATIONS)\nretCode = dsdetachjob(jobHandle)\nnoOfInvocations = dcount(invList, \",\")\ninvList = ereplace(invList, \",\", Config.FM)\n(1.0 until convertToInt(noOfInvocations)).zipWithIndex.map{ case (_invocation, invocationIndex) =>\nvar invocation = _invocation\njobInvStatus = 0.0\njobInvocation = invList(invocation)\njobInvocationID = field3(jobInvocation, \".\", 2.0)\nnoOfInvocationIDComponents = dcount(jobInvocationID, \"_\")\ninvocationIDComponentList = ereplace(jobInvocationID, \"_\", Config.FM)\ninvocationTableName = \"\"\n(2.0 until convertToInt(noOfInvocationIDComponents - 1.0)).zipWithIndex.map{ case (_invocationComponent, invocationComponentIndex) =>\nvar invocationComponent = _invocationComponent\ninvocationTableName = ds_string_concat(ds_string_concat(invocationTableName, \"_\"), invocationIDComponentList(invocationComponent))\n.toArray\ninvocationTableName = ds_right(invocationTableName, ds_len(invocationTableName) - 1.0)\nif(invocationTableName == argTargetTable){\njobHandle = dsattachjob(jobInvocation, DSJ.ERRFATAL)\njobInvStatus = dsgetjobinfo(jobHandle, DSJ.JOBSTATUS)\nretCode = dsdetachjob(jobHandle)\nif(jobInvStatus == StatusToCheckFOR){\ndsloginfo(ds_string_concat(ds_string_concat(\"Job , \", jobInvocation), \"Is running\"), DSJ.ME)\nsleepFORABit = true\n\n.break;\n\n} else {}\n} else {}\nif(sleepFORABit){\n\n.break;\n\n} else {}\n}.toArray\nif(ds_not(sleepFORABit)){\njobHandle = dsattachjob(\"sqGenericRestartableLoad_P2G\", DSJ.ERRFATAL)\ninvList = dsgetjobinfo(jobHandle, DSJ.JOBINVOCATIONS)\nretCode = dsdetachjob(jobHandle)\nnoOfInvocations = dcount(invList, \",\")\ninvList = ereplace(invList, \",\", Config.FM)\nsleepFORABit = false\n(1.0 until convertToInt(noOfInvocations)).zipWithIndex.map{ case (_invocation, invocationIndex) =>\nvar invocation = _invocation\njobInvStatus = 0.0\njobInvocation = invList(invocation)\njobInvocationID = field3(jobInvocation, \".\", 2.0)\nnoOfInvocationIDComponents = dcount(jobInvocationID, \"_\")\ninvocationIDComponentList = ereplace(jobInvocationID, \"_\", Config.FM)\ninvocationTableName = \"\"\n(2.0 until convertToInt(noOfInvocationIDComponents - 1.0)).zipWithIndex.map{ case (_invocationComponent, invocationComponentIndex) =>\nvar invocationComponent = _invocationComponent\ninvocationTableName = ds_string_concat(ds_string_concat(invocationTableName, \"_\"), invocationIDComponentList(invocationComponent))\n}.toArray\ninvocationTableName = ds_right(invocationTableName, ds_len(invocationTableName) - 1.0)\nif(invocationTableName == argTargetTable){\njobHandle = dsattachjob(jobInvocation, DSJ.ERRFATAL)\njobInvStatus = dsgetjobinfo(jobHandle, DSJ.JOBSTATUS)\nretCode = dsdetachjob(jobHandle)\nif(jobInvStatus == StatusToCheckFOR){\ndsloginfo(ds_string_concat(ds_string_concat(\"Sequence , \", jobInvocation), \"Is running\"), DSJ.ME)\nsleepFORABit = true\n\n.break;\n\n} else {}\n} else {}\nif(sleepFORABit){\n\n.break;\n\n} else {}\n}.toArray\n} else {}\nloopCounter = loopCounter + 1.0\nif(loopCounter > maxLoops){\nabortOnTimeout = true\n} else {}\nif(sleepFORABit){\ndsloginfo(ds_string_concat(ds_string_concat(ds_string_concat(ds_string_concat(\"As job/sequence FOR table \", argTargetTable), \"is already running going to pause FOR \"), argSleepMins), \"minutes\"), DSJ.ME)\nsleep(argSleepMins * 60.0)\n} else {}\n}\n\nif(abortOnTimeout){\ndslogfatal(ds_string_concat(ds_string_concat(\"aborting as been waiting FOR more than \", argAbortOnTimeoutMins), \"minutes\"), DSJ.ME)\n} else {}\ndsloginfo(ds_string_concat(ds_string_concat(\"No jobs running for table table \", argTargetTable), \"So ok to finish \"), DSJ.ME)\nAns = 0.0\nAns\n}) }"}