{"initCode":"","code":"\n    udf((InputArg: String, ErrorCode: String) => {\n      var pUKDWSCHEMA: Any = null\n      var aSchemaRecs: Any = null\n      var pSUBJECT: Any = null\n      var schemaLine_size: Any = null\n      var sRecord: Any = null\n      var pSchemaFile: Any = null\n      var sFieldName: Any = null\n      var iNumRecs: Any = null\n      var sParams: Any = null\n      var sFormatRec: Any = null\n      var sFormatRecA: Any = null\n      var touch: Any = null\n      var ErrorCode: Any = null\n      var pPIB_ID: Any = null\n      var iEndPos: Any = null\n      var pTABLE_NAME: Any = null\n      var schemaLine_fp: Any = null\n      var rm: Any = null\n      var iNumFields: Any = null\n      var pPartSchemaFile: Any = null\n      var schemaLine: Any = null\n      var iTag: Any = null\n      var pSCHEMAPATH: Any = null\n      var pUKDWTEMPFILEPATH: Any = null\n      ErrorCode = 0.0 == UATE\n      ProgramName\n      TO\n      \"rtDominoBuildMigrateSchema\"\n      sParams = convert3(\",\", Config.FM, InputArg)\n      pUKDWSCHEMA = sParams(1.0)\n      pPIB_ID = sParams(2.0)\n      pSCHEMAPATH = sParams(3.0)\n      pUKDWTEMPFILEPATH = sParams(4.0)\n      pTABLE_NAME = sParams(5.0)\n      pSUBJECT = sParams(6.0)\n      pSchemaFile = ds_string_concat(\n        ds_string_concat(ds_string_concat(pSCHEMAPATH, \"/\"), pTABLE_NAME),\n        \".sch\"\n      )\n      pPartSchemaFile = ds_string_concat(\n        ds_string_concat(\n          ds_string_concat(\n            ds_string_concat(\n              ds_string_concat(\n                ds_string_concat(\n                  ds_string_concat(\n                    ds_string_concat(\n                      ds_string_concat(pUKDWTEMPFILEPATH, \"/\"),\n                      pSUBJECT\n                    ),\n                    \"_\"\n                  ),\n                  pPIB_ID\n                ),\n                \"_\"\n              ),\n              pUKDWSCHEMA\n            ),\n            \"_\"\n          ),\n          pTABLE_NAME\n        ),\n        \".sch\"\n      )\n      aSchemaRecs = \"\"\n\n      import scala.util.control._\n      val openseq = new Breaks;\n      openseq.breakable {\n        pSchemaFile = ds_openseq(schemaVar)\n      \n\n      import scala.util.control._\n      val readseq = new Breaks;\n      readseq.breakable {\n        schemaLine_size = ds_filesize(schemaLine)\n        schemaLine_fp = ds_readseq(schemaVar)\n        (0 until convertToInt(schemaLine_size)).zipWithIndex.map {\n          case (_i, iIndex) =>\n            var i = _i\n            schemaLine = schemaLine_fp(i)\n            aSchemaRecs(-1.0) = schemaLine\n        }.toArray\n      }\n\n      ds_closeseq(schemaVar)\n      sFormatRecA = \"\"\n      (1.0 until convertToInt(\n        dcount(aSchemaRecs, Config.FM)\n      )).zipWithIndex.map {\n        case (_i, iIndex) =>\n          var i = _i\n          if (ds_right(ds_trim(aSchemaRecs(i)), 1.0) == \";\") {\n            sFieldName = ds_trim(\n              trim3(\n                ds_trim(field3(ds_trim(aSchemaRecs(i)), \":\", 1.0)),\n                \"(\",\n                \"L\"\n              )\n            )\n            sRecord = trim3(aSchemaRecs(i), \"(\", \"L\")\n            if (\n              index(\n                \"PIB_ID IP_ID REC_ACDT TRAN_RNK_ID REC_TS\",\n                sFieldName,\n                1.0\n              ) == 0.0\n            ) {\n              if (index(sRecord, \"max=\", 1.0) > 0.0) {\n                sFormatRecA(-1.0) = sRecord\n              } else if (index(sRecord, \"string[\", 1.0) > 0.0) {\n                sRecord = ereplace(sRecord, \"string[\", \"string[max=\")\n                iEndPos = index(sRecord, \"]\", 1.0)\n                sFormatRecA(-1.0) = ds_string_concat(\n                  datastage_substring(sRecord, 1.0, iEndPos),\n                  \"{null_field=''};\"\n                )\n              } else sFormatRecA(-1.0) = sRecord\n            } else {}\n          } else {}\n      }.toArray\n      sFormatRec = \"\"\n      iNumFields = dcount(sFormatRecA, Config.FM)\n      (1.0 until convertToInt(iNumFields)).zipWithIndex.map {\n        case (_o, oIndex) =>\n          var o = _o\n          sFormatRec(o) = \"\"\n          iTag = -1.0\n          (1.0 until convertToInt(iNumFields)).zipWithIndex.map {\n            case (_x, xIndex) =>\n              var x = _x\n              if (\n                ((sFormatRecA(x) <= sFormatRec(o)) || (sFormatRec(\n                  o\n                ) == \"\")) && (sFormatRecA(x) != \"\")\n              ) {\n                sFormatRec(o) = sFormatRecA(x)\n                iTag = x\n              } else {}\n          }.toArray\n          sFormatRecA(iTag) = \"\"\n      }.toArray\n      touch = ds_string_concat(\"touch \", pPartSchemaFile)\n      rm = ds_string_concat(\"rm \", pPartSchemaFile)\n      dsexecute(\"UNIX\", touch, t1, t2)\n      dsexecute(\"UNIX\", rm, r1, r2)\n      dsexecute(\"UNIX\", touch, t3, t4)\n      iNumRecs = dcount(sFormatRec, Config.FM)\n\n      import scala.util.control._\n      val openseq = new Breaks;\n      openseq.breakable {\n        pPartSchemaFile = ds_openseq(FileVar)\n        weofseq(FileVar)\n        ds_writeseq(FileVar, \"record\")\n        weofseq(FileVar)\n        ds_writeseq(\n          FileVar,\n          \"{final_delim=end, delim=',', null_field='', quote=double}\"\n        )\n        weofseq(FileVar)\n        ds_writeseq(FileVar, \"(\")\n        (1.0 until convertToInt(iNumRecs)).zipWithIndex.map {\n          case (_i, iIndex) =>\n            var i = _i\n            weofseq(FileVar)\n            ds_writeseq(FileVar, sFormatRec(i))\n        }.toArray\n        weofseq(FileVar)\n        ds_writeseq(FileVar, \")\")\n      }\n\n      ds_closeseq(FileVar)\n      null\n    })\n}"}